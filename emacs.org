#+TITLE: Emacs configuration
#+AUTHOR: Marco Dalla Stella
#+EMAIL: marco@dallastella.name
#+STARTUP: overview

* Emacs literal configuration
  I like to keep my cofiguration in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] way, thanks to [[https://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]].


* General settings
** User details
   My personal details.

#+begin_src emacs-lisp
  (setq user-full-name "Marco Dalla Stella")
  (setq user-mail-address "marco@dallastella.name")
#+end_src

** Shell environment
   Ensure environment variables inside Emacs look the same as in the user's
   shell. Also, load keychain environment variables.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (setq exec-path-from-shell-variables '("PATH")
          exec-path-from-shell-arguments '("-l"))
    (exec-path-from-shell-initialize))

  (use-package keychain-environment
    :ensure t
    :init (keychain-refresh-environment))

  (use-package use-package-ensure-system-package
    :ensure t)
#+end_src

** Various minor settings
*** Delete the selection instead of insert

#+begin_src emacs-lisp
  (use-package delsel
    :init (delete-selection-mode))
#+end_src

*** Save point position in files

#+begin_src emacs-lisp
  (use-package saveplace
    :init (save-place-mode 1))
#+end_src

*** Auto-revert buffers of changed files

#+begin_src emacs-lisp
  (use-package autorevert
    :init (global-auto-revert-mode)
    :config
    (setq auto-revert-verbose nil
          ;; Revert Dired buffers, too
          global-auto-revert-non-file-buffers t))
#+end_src

*** Kill ring features
    More killed items, no duplicates in kill ring.

#+begin_src emacs-lisp
  (setq kill-ring-max 200
        kill-do-not-save-duplicates t)
#+end_src

*** Auto-save buffers when they lose focus.

#+begin_src emacs-lisp
  (use-package super-save
    :ensure t
    :config (super-save-mode 1))
#+end_src

*** [[https://github.com/Malabarba/paradox][paradox]] - A better package manager interface.

#+begin_src emacs-lisp
  (use-package paradox
    :ensure t
    :bind (("C-c c p" . paradox-list-packages)
           ("C-c c P" . paradox-upgrade-packages))
    :config (setq paradox-github-token t             ; Don't ask for a token
                  paradox-use-homepage-buttons nil   ; Hide download button
                  paradox-automatically-star nil))   ; Don't star packages automatically
#+end_src


* Graphics and looks
** Frame title
   Show the current buffer name and the full path of the file on the app title
   bar.

#+begin_src emacs-lisp
  (setq-default frame-title-format "%b (%f)")
#+end_src

** Font setup
   I use the PragmataPro font.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      :family "PragmataPro Mono Liga"
                      :height 120)
#+end_src

** Theme
   My favorite theme is solarized dark.

#+begin_src emacs-lisp
  (use-package solarized-theme
    :ensure t
    :config (setq solarized-use-variable-pitch nil
                  solarized-scale-org-headlines nil
                  solarized-use-less-bold t
                  solarized-use-more-italic t
                  x-underline-at-descent-line t)
    (load-theme 'solarized-dark-high-contrast 'no-confirm)
    (set-face-attribute 'mode-line nil :overline nil)
    (set-face-attribute 'mode-line nil :underline nil)
    (set-face-attribute 'mode-line-inactive nil :overline nil)
    (set-face-attribute 'mode-line-inactive nil :underline nil))
#+end_src

** Icons
   Some icons for our modern looking Emacs
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)

  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))

  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))

  (use-package all-the-icons-ibuffer
    :ensure t
    :init (all-the-icons-ibuffer-mode 1))
#+end_src

#+RESULTS:

** Uniquify
   Set unique buffer names.

#+begin_src emacs-lisp
  (use-package uniquify
    :config (setq uniquify-buffer-name-style 'post-forward
                  uniquify-separator ":"))
#+end_src

** Remove menus, bars and everything that's annoying
   I don't like scrollbars nor bars. I've been using Emacs for many years, and
   appreciate a certain minimalist approach to its display.

#+begin_src emacs-lisp
  (setq initial-scratch-message "")
  (when (window-system)
    (tool-bar-mode -1)
    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1))
    (blink-cursor-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1)
    (menu-bar-mode -1))
#+end_src

** Disable annoying prompts and messages

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq ring-bell-function #'ignore
        inhibit-startup-screen t
        initial-scratch-message nil)
  (fset 'display-startup-echo-area-message #'ignore)
#+end_src

** Window margins
   I like to have some space on the left and right edge of the window
   #+begin_src emacs-lisp
     (setq-default left-margin-width 4
                   right-margin-width 4)
   #+end_src
   
** Doom mode line
   [[https://github.com/seagle0128/doom-modeline][doom-modeline]] - A fancy and fast mode-line inspired by minimalism design.

#+begin_src emacs-lisp
  (use-package minions
    :ensure t
    :init (minions-mode)
    :config (setq minions-direct '(cider-mode)))

  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :config (setq doom-modeline-buffer-file-name-style 'buffer-name
                  doom-modeline-minor-modes t
                  doom-modeline-mu4e t
                  doom-modeline-modal-icon nil))
#+end_src

** Perspectives
   The [[https://github.com/nex3/perspective-el][Persqpective]] package provides multiple named workspaces (or
   "perspectives") in Emacs, similar to multiple desktops in window managers
   like Awesome and XMonad, and Spaces on the Mac.

#+begin_src emacs-lisp
  (use-package perspective
    :ensure t
    :config (progn
              (persp-mode 1)
              (setq persp-state-default-file "~/.emacs.d/default-persp")
              (persp-state-load persp-state-default-file)))
#+end_src

** Show matching parenthesis

#+begin_src emacs-lisp
  (show-paren-mode t)

  (use-package rainbow-delimiters
    :ensure t
    :hook ((prog-mode cider-repl-mode) . rainbow-delimiters-mode))
#+end_src

** Prettify symbols

#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src

** Minibuffer settings
*** Allow to read from the minibuffer while in minibuffer

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

*** Show the minibuffer depth (when larger than 1).

#+begin_src emacs-lisp
  (minibuffer-depth-indicate-mode 1)
#+end_src

*** Never use dialogs for minibuffer input and store more history.

#+begin_src emacs-lisp
  (setq use-dialog-box nil
        history-length 1000)
#+end_src

*** Save minibuffer history.

#+begin_src emacs-lisp
  (use-package savehist
    :init (savehist-mode t)
    :config (setq savehist-save-minibuffer-history t
                  savehist-autosave-interval 180))
#+end_src

** Scratch settings
   Use `emacs-lisp-mode' instead of `lisp-interaction-mode' for scratch buffer.

#+begin_src emacs-lisp
  (setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Which-key
   [[https://github.com/justbur/emacs-which-key][Which-key]] â€“ Emacs package that displays available keybindings in popup.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init (which-key-mode)
    :config (setq which-key-idle-delay 0.4
                  which-key-sort-order 'which-key-prefix-then-key-order))
#+end_src



* Editing settings
** Misc variable settings
*** Does anyone type =yes= anymore?

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Fix the scrolling to keep point in the center.

#+begin_src emacs-lisp
  (setq scroll-conservatively 10000
        scroll-preserve-screen-position t)
#+end_src

*** I've been using Emacs for too long to need to re-enable each feature bit-by-bit.

#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

*** Store more history.

#+begin_src emacs-lisp
  (setq history-length 1000)
#+end_src

*** Increase line-spacing (default 0).

#+begin_src emacs-lisp
  (setq-default line-spacing 0.2)
#+end_src

*** Fill column and enable automatic filling in ~text-mode~.

#+begin_src emacs-lisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

** Tabs vs Spaces
   I have learned to distrust tabs in my source code, so let's make sure that we
   only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 2)
#+end_src

   Make tab key do indent first then completion.

#+begin_src emacs-lisp
  (setq-default tab-always-indent 'complete)
#+end_src

** Jumping around
   Use [[https://github.com/abo-abo/avy][Avy]] for jumping around in a buffer.

#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind* (("C-:" . avy-goto-line)
            ("C-;" . avy-goto-char))
    :bind (:map isearch-mode-map
                ("C-'" . avy-isearch)))
#+end_src

** Counsel
   Completion functions with Ivy

#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :init (counsel-mode)
    :bind (("C-c u" . counsel-unicode-char)
           ("C-c r" . counsel-rg)
           ("C-c h h" . counsel-command-history)
           ([remap execute-extended-command] . counsel-M-x)
           ([remap find-file] . counsel-find-file)
           ([remap describe-function] . counsel-describe-function)
           ([remap describe-variable] . counsel-describe-variable))
    :config (setq counsel-mode-override-describe-bindings t
                  counsel-find-file-at-point t))
#+end_src

** Ivy configuration
   [[http://oremacs.com/swiper/][Ivy]] is an interactive interface for completion in Emacs.

#+begin_src emacs-lisp
  (use-package ivy
    :ensure t
    :bind (("C-x M-b" . persp-ivy-switch-buffer)
           ("C-c C-r" . ivy-resume)
           :map ivy-minibuffer-map
           ("<return>" . ivy-alt-done)
           ("C-o" . hydra-ivy/body))
    :config (setq ivy-use-virtual-buffers t
                  ivy-count-format "(%d/%d) ")
    :init (ivy-mode 1))
#+end_src

*** ivy-hydra

#+begin_src emacs-lisp
  (use-package ivy-hydra
    :ensure t
    :after ivy)
#+end_src

*** ivy-rich

#+begin_src emacs-lisp
  (use-package ivy-rich
    :ensure t
    :config (setcdr (assq t ivy-format-functions-alist)
                    #'ivy-format-function-line)
    :init (ivy-rich-mode 1))
#+end_src

** Amx
   [[https://github.com/DarwinAwardWinner/amx][Amx]] is an alternative interface for ~M-x~ in Emacs.

#+begin_src emacs-lisp
  (use-package amx
    :ensure t)
#+end_src

** Aggressive indentation
   Aggressive-indent-mode is a minor mode that keeps your code always indented.
   It re-indents after every change, making it more reliable than
   `electric-indent-mode`.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :init (global-aggressive-indent-mode 1)
    :config
    ;; Free C-c C-q, used in Org and in CIDER
    (unbind-key "C-c C-q" aggressive-indent-mode-map)
    (add-to-list 'aggressive-indent-excluded-modes
                 'cider-repl-mode))
#+end_src

** Easykill
   [[https://github.com/leoliu/easy-kill][Easykill]] - Better kill text.

#+begin_src emacs-lisp
  (use-package easy-kill
    :ensure t
    :bind (([remap kill-ring-save] . easy-kill)
           ([remap mark-sexp]      . easy-mark)))
#+end_src

** Highlight symbols
   [[https://github.com/wolray/symbol-overlay][symbol-overlay.el]] - Highlight symbols with overlays while providing a keymap
   for various operations about highlighted symbols.

#+begin_src emacs-lisp
  (use-package symbol-overlay
    :ensure t
    :bind (:map symbol-overlay-mode-map
                ("M-n" . symbol-overlay-jump-next)
                ("M-p" . symbol-overlay-jump-prev))
    :hook ((prog-mode html-mode css-mode) . symbol-overlay-mode))
#+end_src
** Spell checking

*** aspell

#+begin_src emacs-lisp
  (use-package ispell
    :defer t
    :config (setq ispell-program-name (executable-find "aspell")
                  ispell-extra-args '("--sug-mode=ultra")
                  ispell-dictionary "en"
                  ispell-local-dictionary "en")
    (unless ispell-program-name
      (warn "No spell checker available. Please install hunspell.")))
#+end_src

*** [[https://gitlab.com/ideasman42/emacs-spell-fu][spell-fu]] - Fast highlighting of misspelled words.

#+begin_src emacs-lisp
  (use-package spell-fu
    :ensure t
    :hook ((prog-mode text-mode) . spell-fu-mode))
#+end_src

** Multiple cursors
   [[https://github.com/magnars/multiple-cursors.el][Multiple cursors for emacs.]]

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind* (("C-> n" . mc/mark-next-like-this)
            ("C-> p" . mc/mark-previous-like-this)
            ("C-> a" . mc/mark-all-like-this)
            ("C-> C->" . mc/edit-lines)))
#+end_src

** ibuffer
   Use ibuffer instead of list-buffers.

 #+begin_src emacs-lisp
   (bind-key* "C-x C-b" #'ibuffer)

   (use-package ibuffer-vc
     :ensure t
     :hook (ibuffer . (lambda ()
                        (ibuffer-vc-set-filter-groups-by-vc-root)
                        (unless (eq ibuffer-sorting-mode 'alphabetic)
                          (ibuffer-do-sort-by-alphabetic)))))
 #+end_src

** undo-fu
   [[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]] - Simple, stable undo with redo for emacs.

#+begin_src emacs-lisp
  (use-package undo-fu
    :ensure t
    :bind* (("C-z" . undo-fu-only-undo)
            ("C-S-z" . undo-fu-only-redo)))
#+end_src


* Tools
** Crux
   [[https://github.com/bbatsov/crux][crux]] - A Collection of Ridiculously Useful eXtensions for Emacs.

#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind ("C-^" . crux-top-join-line)
    :config
    (setq save-abbrevs 'silently)
    (setq-default abbrev-mode t))
#+end_src

** Flycheck
   [[http://www.flycheck.org][Flycheck]] automatically checks buffers for errors while you type, and reports
   warnings and errors directly in the buffer and in an optional IDE-like error
   list.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (prog-mode . flycheck-mode)
    :config
    (setq flycheck-standard-error-navigation nil
		   flycheck-display-errors-function
		   #'flycheck-display-error-messages-unless-error-list))
#+end_src

** Projectile
   Projectile is a project interaction library for Emacs. Its goal is to provide
   a nice set of features operating on a project level without introducing
   external dependencies (when feasible).

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :bind
    (:map projectile-mode-map
          ("C-c p" . projectile-command-map))
    :init
    (projectile-mode +1)
    (setq projectile-completion-system 'ivy
          projectile-find-dir-includes-top-level t)
    (projectile-register-project-type 'lein-cljs '("project.clj")
                                      :compile "lein cljsbuild once"
                                      :test "lein cljsbuild test"))
#+end_src

*** Ivy integration with Projectile

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :bind (:map projectile-command-map
                ("p" . counsel-projectile)
                ("f" . counsel-projectile-find-file)
                ("P" . counsel-projectile-switch-project)
                ("r" . counsel-projectile-rg)))
#+end_src

*** Search project with ripgrep

#+begin_src emacs-lisp
  (use-package projectile-ripgrep         ; Search projects with ripgrep
    :ensure t
    :bind (:map projectile-command-map
		("s r" . projectile-ripgrep)))
#+end_src

** Magit configuration
   [[https://github.com/magit/magit][Magit]] - A Git porcelain inside Emacs.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-c v c" . magit-clone)
           ("C-c v C" . magit-checkout)
           ("C-c v d" . magit-dispatch-popup)
           ("C-c v g" . magit-blame)
           ("C-c v l" . magit-log-buffer-file)
           ("C-c v p" . magit-pull)
           ("C-c v v" . magit-status)
           ("C-c v f" . magit-fetch-all)
           ("C-c v R" . vc-refresh-state))
    :config (setq magit-save-repository-buffers 'dontask
                  magit-refs-show-commit-count 'all
                  magit-completing-read-function 'ivy-completing-read))
#+end_src

** diff-hl
   [[https://github.com/dgutov/diff-hl][diff-hl-mode]] highlights uncommitted changes on the left side of the window,
   allows you to jump between and revert them selectively.

#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :config (add-hook 'magit-post-refresh-hook
                      'diff-hl-magit-post-refresh)
    :init
    (diff-hl-dired-mode)
    (global-diff-hl-mode))
#+end_src

** Smartparens
   Smartparens - Minor mode for Emacs that deals with parens pairs and tries to
   be smart about it.

#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :bind (:map smartparens-mode-map
                ("M-R" . sp-raise-sexp))
    :config (require 'smartparens-config)
    (setq sp-highlight-pair-overlay t
          sp-highlight-wrap-overlay t
          sp-highlight-wrap-tag-overlay t
          sp-show-pair-from-inside t)
    (sp-use-smartparens-bindings)
    :init (smartparens-global-strict-mode t))
#+end_src

** Direnv
   direnv integration for emacs.

#+begin_src emacs-lisp
  (use-package direnv
    :ensure t
    :config (direnv-mode))
#+end_src

** wgrep
   [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep.el]] - allows you to edit a grep buffer and apply those changes to the
   file buffer.

#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :defer t)
#+end_src

** ace-windows
   [[https://github.com/abo-abo/ace-window][ace-windows]] - GNU Emacs package for selecting a window to switch to

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind* ("C-x o" . ace-window))
#+end_src

** dired-sidebar

   Let's put dired in a sideabar.

   #+begin_src emacs-lisp
     (use-package dired-sidebar
       :bind (("C-c c d" . dired-sidebar-toggle-sidebar))
       :ensure t
       :commands (dired-sidebar-toggle-sidebar)
       :init
       (add-hook 'dired-sidebar-mode-hook
                 (lambda ()
                   (unless (file-remote-p default-directory)
                     (auto-revert-mode))))
       :config
       (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
       (push 'rotate-windows dired-sidebar-toggle-hidden-commands))
   #+end_src
   

* Productivity
** org-mode
*** org settings
#+begin_src emacs-lisp
  (use-package org
    :ensure t
    :config
    (setq org-agenda-files (list "~/org/")
          org-default-notes-file "inbox.org"
          org-todo-keywords '((sequence "TODO" "NEXT" "|" "DONE"))
          org-log-done t
          org-archive-location "~/org/archive.org::datatree/"
          org-archive-mark-done t
          org-hide-emphasis-markers t
          org-fontify-quote-and-verse-blocks t
          org-confirm-babel-evaluate nil
          org-refile-targets '((org-agenda-files :maxlevel . 1))
          org-refile-allow-creating-parent-nodes 'confirm))
#+end_src

*** org-super-agenda
    [[https://github.com/alphapapa/org-super-agenda][org-super-agenda: Supercharge your Org daily/weekly agenda...]]

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :config (setq org-deadline-warning-days 7
                  org-agenda-block-separator 9472
                  org-agenda-skip-scheduled-if-done t)
    :init (org-super-agenda-mode))
#+end_src

*** org-cliplink
#+begin_src emacs-lisp
  (use-package org-cliplink
    :ensure t
    :bind ("C-c o i" . org-cliplink))
#+end_src

*** org-mru-clock

    [[https://github.com/unhammer/org-mru-clock][org-mru-clock]] - Pre-fill your clock history with clocks from your agenda
    files (and other open org files) so you can clock in to your most recent
    clocks regardless of whether you just started Emacs or have had it running
    for decades.

#+begin_src emacs-lisp
  (use-package org-mru-clock
    :ensure t
    :bind* (("C-c t i" . org-mru-clock-in)
            ("C-c t j" . org-mru-clock-select-recent-task)
            ("C-c t o" . org-clock-out))
    :init (setq org-mru-clock-how-many 100
                org-mru-clock-completing-read #'ivy-completing-read
                org-mru-clock-files #'org-agenda-files))
#+end_src

*** org-clock-csv
    Extracts clock entries from org files and convert them into CSV format. It
    is intended to facilitate clocked time analysis in external programs.

#+begin_src emacs-lisp
  (use-package org-clock-csv
    :ensure t)
#+end_src

*** yankpad
    [[https://github.com/Kungsgeten/yankpad][GitHub - Kungsgeten/yankpad: Paste snippets from an org-mode file]]

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t)
  (use-package yankpad
    :ensure t
    :init
    (setq yankpad-file "~/cloud/mds/Org/yankpad.org")
    (bind-keys :prefix-map yank-map
	       :prefix "C-c y"
	       ("c" . yankpad-set-category)
	       ("e" . yankpad-edit)
	       ("i" . yankpad-insert)
	       ("m" . yankpad-map)
	       ("r" . yankpad-reload)
	       ("x" . yankpad-expand)))
#+END_SRC

*** capture templates

#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("t" "Task" entry (file "inbox.org")
           "* TODO %?\n")
          ("r" "Task with ref" entry (file "inbox.org")
           "* TODO %?\n%a")
          ("T" "Clockable task" entry (file+headline "inbox.org")
           "* TODO %?\n" :clock-in t :clock-keep t)
          ("m" "Maybe" entry (file+headline "someday.org" "Someday / Maybe")
           "* MAYBE %?\n")
          ("j" "Journal" entry (file+olp+datetree "~/org/journal.org")
           "** %<%H:%M> %?\n")))
#+end_src


* Coding
** Completion with company
   [[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
   "complete anything". It uses pluggable back-ends and front-ends to retrieve
   and display completion candidates.

#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :bind (:map company-active-map
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous))
    :config (setq company-mode-idle-dalay nil
                  company-tooltip-align-annotations t
                  company-dabbrev-ignore-case t
                  company-show-numbers t
                  company-dabbrev-downcase nil)
    :bind (:map prog-mode-map
                ("TAB" . company-indent-or-complete-common))
    :init (global-company-mode))

  ;; Show likelier candidates on top
  (use-package company-statistics
    :ensure t
    :after company
    :config (company-statistics-mode))
#+end_src

** Clojure
   Clojure settings for Emacs

*** Clojure development environment

#+begin_src emacs-lisp
  (use-package cider
    :ensure t
    :hook (cider-mode . eldoc-mode)
    :bind (:map cider-mode-map
                ("C-c M-l" . cider-load-all-project-ns))
    :config (setq cider-offer-to-open-cljs-app-in-browser nil
                  cider-auto-select-error-buffer nil))
#+end_src

*** CIDER mode for REPL interaction

#+begin_src emacs-lisp
  (use-package cider-mode
    :ensure cider
    :config (setq cider-font-lock-dynamically t
                  cider-invert-insert-eval-p t
                  cider-save-file-on-load t
                  cider-switch-to-repl-after-insert-p nil
                  cider-repl-pop-to-buffer-on-connect 'display-only))
#+end_src

*** Clojure Flycheck
    Flycheck using clj-kondo

#+begin_src emacs-lisp
  (use-package flycheck-clj-kondo
    :ensure t)
#+end_src

*** Major mode for Clojure files

#+begin_src emacs-lisp
  (use-package clojure-mode
    :ensure t
    :hook  ((clojure-mode . cider-mode)
            (clojure-mode . subword-mode))
    :config (define-clojure-indent	; Fix indentation of some common macros
              (for-all 1)
              (defroutes 'defun)
              (GET 2)
              (POST 2)
              (PUT 2)
              (DELETE 2)
              (HEAD 2)
              (ANY 2)
              (context 2)))
#+end_src

*** Font-locking for Clojure mode

#+begin_src emacs-lisp
  (use-package clojure-mode-extra-font-locking
    :ensure t
    :after clojure-mode)
#+end_src

*** Client for Clojure nREPL

#+begin_src emacs-lisp
  (use-package nrepl-client
    :ensure cider
    :config (setq nrepl-hide-special-buffers t))
#+end_src

*** REPL interactions with CIDER

#+begin_src emacs-lisp
  (use-package cider-repl
    :ensure cider
    :hook ((cider-repl-mode . eldoc-mode)
           (cider-repl-mode . subword-mode))
    :bind (:map cider-repl-mode-map
                ("RET" . cider-repl-newline-and-indent)
                ("C-RET" . cider-repl-return)
                ("C-c c l" . cider-repl-clear-buffer))
    :config (setq cider-repl-wrap-history t
                  cider-repl-history-size 1000
                  cider-repl-history-file
                  (locate-user-emacs-file "cider-repl-history")
                  cider-repl-display-help-banner nil ; Disable help banner
                  cider-repl-pop-to-buffer-on-connect t))
#+end_src

*** Kaocha test runner
    An emacs package for running Kaocha tests via CIDER.

#+begin_src emacs-lisp
  (use-package kaocha-runner
    :ensure t
    :after cider
    :bind (:map clojure-mode-map
                ("C-c k a" . kaocha-runner-run-all-tests)
                ("C-c k h" . kaocha-runner-hide-windows)
                ("C-c k r" . kaocha-runner-run-tests)
                ("C-c k t" . kaocha-runner-run-test-at-point)
                ("C-c k w" . kaocha-runner-show-warnings))
    :config (setq kaocha-runner-failure-win-min-height 20
                  kaocha-runner-ongoing-tests-win-min-height 20
                  kaocha-runner-output-win-max-height 20))
#+end_src

** Web Development
   I use web-mode, css-mode and js2 for web development.

*** web-mode

#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode "\\.html\\'"
    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2))
#+end_src

*** js2 - A better JavaScript support

#+begin_src emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode "\\.js\\'"
    :hook (js2-mode . js2-highlight-unused-variables-mode)
    :config (setq-default js2-basic-offset 2))
#+end_src

*** Typescript support with [[https://github.com/ananthakumaran/tide][tide]]

#+begin_src emacs-lisp
  (use-package tide
    :ensure t
    :after (typescript-mode company flycheck)
    :hook ((typescript-mode . tide-setup)
           (typescript-mode . tide-hl-identifier-mode))
    :config (setq typescript-indent-level 2))
#+end_src

   Better CSS support.

#+begin_src emacs-lisp
  (use-package css-mode
    :ensure t
    :mode "\\.css\\'"
    :hook (css-mode-hook . (lambda () (run-hooks 'prog-mode-hook)))
    :config (setq css-indent-offset 2))
#+end_src

   Eldoc for CSS.

#+begin_src emacs-lisp
  (use-package css-eldoc
    :ensure t
    :hook (css-mode . turn-on-css-eldoc)
    :commands (turn-on-css-eldoc))
#+end_src

   JSON specific mode.

#+begin_src emacs-lisp
  (use-package json-mode                  ; JSON editing
    :ensure t
    :mode "\\.json\\'")
#+end_src

** Janet
   [[https://janet-lang.org][Janet]] is a functional and imperative programming language.

#+begin_src emacs-lisp
  (use-package janet-mode
    :ensure t
    :mode ("\\.janet\\'" . janet-mode))
#+end_src

** LUA

   #+begin_src emacs-lisp
     (use-package lua-mode
       :ensure t
       :defer t
       :mode ("\\.lua" . lua-mode)
       :config
       (setq lua-indent-level 2))
   #+end_src

** Fennel
   [[https://fennel-lang.org/][Fennel]] is a programming language that brings together the speed, simplicity,
   and reach of Lua with the flexibility of a lisp syntax and macro system.

#+begin_src emacs-lisp
  (use-package fennel-mode
    :ensure t
    :mode ("\\.fnl" . fennel-mode))
#+end_src

** YAML
   Editing YAML files.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :defer t)
#+end_src


* Global keybindings
** Set C-x C-k to kill the current buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-k") 'kill-this-buffer)
#+end_src

** Bind M-g to goto-line

#+begin_src emacs-lisp
  (global-set-key (kbd "M-g") 'goto-line)
#+end_src

** Comment and uncomment regions

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c c c") 'comment-or-uncomment-region)
#+end_src

** Org agenda and capture
   org-mode shortcuts

  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c t t") 'org-capture)
    (global-set-key (kbd "C-c t a") 'org-agenda)
    (global-set-key (kbd "C-c t r") 'org-refile)
  #+end_src



* BEERWARE LICENSE
  "THE BEER-WARE LICENSE" (Revision 42): <marco@dallastella.name> wrote this
  file. As long as you retain this notice you can do whatever you want with this
  stuff. If we meet some day, and you think this stuff is worth it, you can buy me
  a beer in return.
