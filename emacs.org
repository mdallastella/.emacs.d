#+title: MDS Emacs
#+subtitle: My literate emacs configuration
#+property: header-args :results silent :comments no
#+startup: fold

* General
** Use lexical-binding, see why [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][here]].
   #+begin_src elisp
     ;;; -*- lexical-binding: t -*-
   #+end_src
** My personal information
   #+begin_src elisp
     (setq user-full-name "Marco Dalla Stella"
           user-mail-address "marco@dallastella.name")
   #+end_src
** Access to shell PATH
   Ensure environment variables inside Emacs look the same as in the
   user’s shell. Also, load keychain environment variables.
   #+begin_src elisp
     (use-package exec-path-from-shell
       :ensure t
       :config
       (exec-path-from-shell-initialize))
   #+end_src
** Save history
   #+begin_src elisp
     (use-package savehist
       :ensure nil
       :config
       (setq history-length 10000
           history-delete-duplicates t
           savehist-save-minibuffer-history t
           savehist-additional-variables '(kill-ring
                                           search-ring
                                           regexp-search-ring))
       :init
       (savehist-mode t))
   #+end_src
** Keep backups out of the way
   Store backups and autosave files in ~/tmp~
   #+begin_src elisp
     (setq backup-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms
           `((".*" ,temporary-file-directory t)))
   #+end_src
** Auto Revert
   Automatically reload changes on a file if needed.
   #+begin_src elisp
     (use-package autorevert
       :ensure nil
       :config
       (setq global-auto-revert-non-file-buffers t)
       :init
       (global-auto-revert-mode t))
   #+end_src
** Uniquify buffer names
   Meaningful names for buffers with the same name.
   #+begin_src elisp
     (use-package uniquify
       :ensure nil
       :config
       (setq uniquify-buffer-name-style 'post-forward-angle-brackets
             uniquify-separator "/"
             uniquify-ignore-buffers-re "^\\*"))
   #+end_src
** Recent files
   Save recent files
   #+begin_src elisp
     (use-package recentf
       :ensure nil
       :config
       (setq recentf-max-saved-items 500
             recentf-max-menu-items 15))
   #+end_src
** Unbind Ctrl-z
   I don't like to hide Emacs, and C-x u is too long.
   #+begin_src elisp
     (global-unset-key (kbd "C-z"))
   #+end_src
** Scratch buffer
   Use `emacs-lisp-mode’ instead of `lisp-interaction-mode’ for scratch buffer.
   #+begin_src elisp
     (setq initial-major-mode 'emacs-lisp-mode
           initial-scratch-message ";; Happy coding!\n\n")
   #+end_src


* Keybinding
  The most frequent keybindings are structured in a mnemonic way for
  me. On evil-mode, ~SPC~ is the "leader", then a letter that identify
  the scope: ~c~ for generic functions, ~b~ for buffer, ~d~ for directories,
  ~f~ for files, ~p~ for projects, ~m~ for the active major-modes and so
  on.
** general
   #+begin_src elisp
     (setq leader-key "C-z")

     (use-package general
       :demand t
       :config
       (general-define-key
        :prefix leader-key
         ;; Buffers (b)
         "b" '(:ignore t :wk "Buffers")
         "bb" 'counsel-buffer-or-recentf
         "bl" 'counsel-ibuffer
         "bw" 'save-buffer
         "bk" 'kill-this-buffer
         "bK" 'kill-buffer
         ;; Files (f)
         "f" '(:ignore t :wk "Files")
         "ff" 'counsel-find-file
         "fd" 'dired
         ;; Utility (u)
         "u" '(:ignore t :wk "Utility")
         "uD" 'package-delete
         ;; Toggle (t)
         "t" '(:ignore t :wk "Toggle")
         "tp" 'smartparens-strict-mode
         "ts" 'flyspell-mode
         ;; Windows (w)
         "w" '(:ignore t :wk "Windows")
         "wo" 'other-window
         "wv" 'split-window-vertically
         "w-" 'split-window-horizontally
         "w1" 'delete-other-windows
         ;; Quit
         "qq" 'save-buffers-kill-emacs))
   #+end_src

** which-key
   [[https://github.com/justbur/emacs-which-key][Which-key]] – Emacs package that displays available keybindings in popup.
   #+begin_src elisp
     (use-package which-key
       :diminish
       :init
       (setq which-key-sort-order #'which-key-key-order-alpha
             which-key-sort-uppercase-first nil
             which-key-add-column-padding 1
             which-key-max-display-columns nil
             which-key-min-display-lines 6
             which-key-side-window-slot -10)
       :config
       (which-key-setup-side-window-bottom)
       (which-key-mode t))
   #+end_src


* UI
** Frame title
   Show the current buffer name and the full path of the file on the app title bar
   #+begin_src elisp
     (setq-default frame-title-format "%b (%f)")
   #+end_src
** Font setup
   Set my favourite font
   #+begin_src elisp
     (set-frame-font "PragmataPro Mono Liga 12")
   #+end_src
** Theme
   [[https://github.com/hlissner/emacs-doom-themes][Solarized theme by emacs-doom-themes]]
   #+begin_src elisp
     (use-package doom-themes
       :config
       (load-theme 'doom-solarized-dark t)
       (doom-themes-visual-bell-config)
       (doom-themes-org-config)
       (custom-set-faces
        `(org-block ((t (:background nil))))
        `(org-block-begin-line ((t (:background nil))))
        `(org-block-end-line ((t (:background nil))))))
   #+end_src
** Modeline
   Modeline from [[https://github.com/seagle0128/doom-modeline][Doom]]
   #+begin_src elisp
     (use-package minions
       :ensure t
       :init
       (minions-mode)
       :config
       (setq minions-direct '(cider-mode)))

     (use-package doom-modeline
       :hook
       (after-init . doom-modeline-mode)
       :config
       (setq doom-modeline-buffer-file-name-style 'buffer-name
             doom-modeline-minor-modes t
             doom-modeline-icon t
             doom-modeline-major-mode-color-icon t
             doom-modeline-height 15)

       (doom-modeline-mode))
   #+end_src
** Show matching parenthesis
   #+begin_src elisp
     (use-package paren
       :config
       (setq show-paren-when-point-inside-paren t
             show-paren-when-point-in-periphery t)
       :init
       (show-paren-mode t))

     (use-package rainbow-delimiters
       :hook
       ((prog-mode cider-repl-mode) . rainbow-delimiters-mode))
   #+end_src
** Use icons
   [[https://github.com/domtronn/all-the-icons.el][all-the-icons.el]]: A utility package to collect various Icon Fonts
   and propertize them within Emacs.
   #+begin_src elisp
     (use-package all-the-icons)

     (use-package all-the-icons-ivy-rich
       :init
       (all-the-icons-ivy-rich-mode 1))
   #+end_src
** Increase line-spacing
   #+begin_src elisp
     (setq-default line-spacing 0.2)
   #+end_src
** Highlight indent
   [[https://github.com/DarthFennec/highlight-indent-guides][Highlight Indent Guides]]: highlights indentation levels.
   #+begin_src elisp
     (use-package highlight-indent-guides
       :hook
       (prog-mode . highlight-indent-guides-mode)
       :config
       (setq highlight-indent-guides-method 'bitmap
             highlight-indent-guides-responsive 'top
             highlight-indent-guides-delay 0))
   #+end_src
** Prettify symbols
   #+begin_src elisp
     (global-prettify-symbols-mode t)
   #+end_src
** Window margins
   I like to have some space on the left and right edge of the window.
   #+begin_src emacs-lisp :results output silent
     (setq-default left-margin-width 4
                   right-margin-width 4)
     (set-fringe-mode 10)
   #+end_src


* Editing
** UTF-8 by default
   #+begin_src elisp
     (set-charset-priority 'unicode)
   #+end_src
** Use ALWAYS spaces to indent, NEVER tabs
   #+begin_src elisp
     (setq-default indent-tabs-mode nil           ; Never use tabs
                   tab-always-indent 'complete    ; Indent or complete
                   tab-width 4                    ; Show eventual tabs as 4 spaces
                   evil-shift-width tab-width)    ; Same for < and > for evil-mode
   #+end_src
** Newline at the end of a file
   #+begin_src elisp
     (setq require-final-newline t)
   #+end_src
** Delete/replace current selection
   #+begin_src elisp
     (delete-selection-mode t)
   #+end_src
** Deal with whitespaces
   #+begin_src elisp
     (use-package whitespace
       :ensure nil
       :hook
       (before-save . whitespace-cleanup)
       :config
       (setq whitespace-line-column nil))
   #+end_src
** Direnv
   Direnv integration with Emacs
   #+begin_src elisp
     (use-package direnv
       :general
       (:prefix leader-key
                "ud" '(:ignore t :wk "Direnv")
                "uda" '(direnv-allow :wk "Direnv allow"))
       :config
       (direnv-mode))
   #+end_src
** Avy zap
   Zap to char using avy.
   #+begin_src elisp
     (use-package avy-zap
       :general
       (:prefix leader-key
                "uz" '(avy-zap-to-char-dwim :wk "Avy zap")))
   #+end_src
** Multiple cursors
   [[https://github.com/magnars/multiple-cursors.el][Multiple cursors for Emacs]]
   #+begin_src elisp
     (use-package multiple-cursors
       :general
       (:prefix leader-key
                "m" '(:ignore t :which-key "Multiple cursors")
                "mn" 'mc/mark-next-like-this
                "mp" 'mc/mark-previous-like-this
                "ma" 'mc/mark-all-like-this
                "m>" 'mc/edit-lines))
   #+end_src
** undo-fu
   [[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]] - Simple, stable undo with redo for emacs.
   #+begin_src elisp
     (use-package undo-fu)
   #+end_src
** wgrep
   [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep.el]] - allows you to edit a grep buffer and apply those changes
   to the file buffer.
   #+begin_src elisp
     (use-package wgrep)
   #+end_src
** easy-kill
   [[https://github.com/leoliu/easy-kill][easy-kill]]: Provide commands easy-kill and easy-mark to let users
   kill or mark things easily.

   #+begin_src elisp
     (use-package easy-kill
       :bind (([remap kill-ring-save] . easy-kill)
              ([remap mark-sexp] . easy-mark)))
   #+end_src


* Tools
** Paradox
   [[https://github.com/Malabarba/paradox][Paradox]]: Project for modernizing Emacs' Package Menu.
   #+begin_src elisp
     (use-package paradox
       :config
       (setq paradox-github-token paradox-gh-token)
       :general
       (:prefix leader-key
                "up" '(paradox-list-packages :wk "Packages list")
                "uP" '(paradox-upgrade-packages :wk "Packages update"))
       :init
       (paradox-enable))
   #+end_src
** Avy
   [[https://github.com/abo-abo/avy][Avy]] is a GNU Emacs package for jumping to visible text using a
   char-based decision tree.
   #+begin_src elisp
     (use-package avy
       :defer t
       :general
       (:prefix leader-key
                "j" '(avy-goto-char-timer :wk "Goto char")
                "J" '(avy-goto-line :wk "Goto line"))
       :config
       (setq avy-timeout-seconds 0.3
             avy-style 'pre))
   #+end_src
** Crux
   A [[https://github.com/bbatsov/crux][Collection of Ridiculously Useful eXtensions for Emacs]]. Crux
   bundles many useful interactive commands to enhance your overall
   Emacs experience.
   #+begin_src elisp
     (use-package crux
       :general
       (:prefix leader-key
                "uU" '(crux-sudo-edit :wk "Sudo edit")
                "fr" '(crux-rename-file-and-buffer :wk "Rename file/buffer"))
       :config
       (global-set-key [remap move-beginning-of-line] #'crux-move-beginning-of-line)
       (global-set-key [remap kill-whole-line] #'crux-smart-kill-line)
       (global-set-key [(shift return)] #'crux-smart-open-line)
       (global-set-key [(ctrl shift return)] #'crux-smart-open-line-above))
   #+end_src
** Ivy, Amx, Counsel, Swiper
   [[https://github.com/abo-abo/swiper][Ivy]] is a generic completion mechanism for Emacs. While it operates
   similarly to other completion schemes such as icomplete-mode, Ivy
   aims to be more efficient, smaller, simpler, and smoother to use
   yet highly customizable.
   #+begin_src elisp
     (use-package ivy
       :diminish
       :init
       (use-package amx :defer t)
       (use-package counsel :diminish :config (counsel-mode t))
       (use-package swiper :defer t)
       (ivy-mode t)
       :general
       (:prefix leader-key
                "bs" '(counsel-grep-or-swiper :wk "Search/Grep")
                "bS" '(swiper-thing-at-point :wk "Search thing at poing")
                "fg" '(counsel-rg :wk "Ripgrep"))
       :bind
       ((:map ivy-minibuffer-map
              ("C-r" . ivy-previous-line-or-history)
              ("M-RET" . ivy-immediate-done)))
       :custom
       (ivy-use-virtual-buffers t)
       (ivy-height 10)
       (ivy-on-del-error-function nil)
       (ivy-magic-slash-non-match-action 'ivy-magic-slash-non-match-create)
       (ivy-count-format "【%d/%d】")
       (ivy-wrap t))

     (use-package ivy-rich
       :after ivy
       :config
       (setcdr (assq t ivy-format-functions-alist) 'ivy-format-function-line)
       (ivy-rich-mode t))
   #+end_src
** Spell checking
*** ispell
    #+begin_src elisp
      (use-package ispell
        :config
        (setq ispell-program-name (executable-find "aspell")
              ispell-extra-args '("--sug-mode=ultra")
              ispell-dictionary "en"
              ispell-local-dictionary "en")
        (unless ispell-program-name
          (warn "No spell checker available. Please install hunspell.")))
    #+end_src
*** flyspell
    #+begin_src elisp
      (defun flyspell-italian ()
        (interactive)
        (ispell-change-dictionary "italian")
        (flyspell-buffer))

      (defun flyspell-english ()
        (interactive)
        (ispell-change-dictionary "default")
        (flyspell-buffer))

      (use-package flyspell
        :ensure nil
        :general
        (:prefix leader-key
                 "s" '(:ignore t :wk "Flyspell")
                 "sd" '(flyspell-english :wk "English dictionary")
                 "si" '(flyspell-italian :wk "Italian dictionary")
                 "sb" '(flyspell-buffer :wk "Check buffer")
                 "sr" '(flyspell-region :wk "Check region"))
        :hook
        ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode)))

      (use-package flyspell-correct
        :after flyspell
        :general
        (:prefix leader-key
                 "ss" '(flyspell-correct-wrapper :wk "Correct word")))

      (use-package flyspell-correct-ivy
        :after flyspell-correct)
    #+end_src

** Company
   #+begin_src elisp
     (use-package company
       :config
       (setq company-begin-commands '(self-insert-command)
             company-idle-delay 0.1
             company-show-quick-access t
             company-tooltip-align-annotations t)
       :hook
       (after-init . global-company-mode))
   #+end_src
** Smartparens
   #+begin_src elisp
     (use-package smartparens
       :config
       (use-package smartparens-config :ensure smartparens)
       (smartparens-global-strict-mode t))
   #+end_src
** Perspective
   The [[https://github.com/nex3/perspective-el][Perspective]] package provides multiple named workspace (or
   "perspectives") in Emacs, similar to multiple desktops in window managers
   like Awesome and XMonad, and Spaces on the Mac.
   #+begin_src elisp
     (use-package perspective
       :general
       (:prefix leader-key
        "x" '(:ignore t :wk "Workspaces")
        "xx" '(persp-switch :wk "Switch workspace")
        "xr" '(persp-rename :wk "Rename workspace")
        "xk" '(persp-kill :wk "Kill workspace"))
       :config
       (persp-mode t)
       (setq persp-state-default-file (no-littering-expand-etc-file-name "default-persp"))
       (when (file-exists-p persp-state-default-file)
         (persp-state-load persp-state-default-file)))
   #+end_src
** Helpful
   [[https://github.com/Wilfred/helpful][Helpful]] is an alternative to the built-in Emacs help that provides
   much more contextual information.
   #+begin_src elisp
     (use-package helpful
       :custom
       (counsel-describe-function-function #'helpful-callable)
       (counsel-describe-variable-function #'helpful-variable)
       :bind
       ([remap describe-function] . helpful-function)
       ([remap describe-symbol] . helpful-symbol)
       ([remap describe-variable] . helpful-variable)
       ([remap describe-command] . helpful-command)
       ([remap describe-key] . helpful-key))
   #+end_src
** vterm
   [[https://github.com/akermu/emacs-libvterm][vterm]] is fully-fledged terminal emulator inside GNU Emacs based on
   libvterm.

   #+begin_src elisp
     (use-package vterm
       :general
       (:prefix leader-key
                "ut" '(vterm :wk "Terminal")))
   #+end_src

* Programming
** Projectile
   Projectile is a project interaction library for Emacs. Its goal is
   to provide a nice set of features operating on a project level
   without introducing external dependencies (when feasible).
   #+begin_src elisp
     (use-package projectile
       :ensure t
       :general
       (:prefix leader-key
                "p" '(:keymap projectile-command-map :package projectile :wk "Projectile"))
       :init
       (setq projectile-find-dir-includes-top-level t
             projectile-switch-project-action #'projectile-find-file
             projectile-sort-order 'recentf
             projectile-completion-system 'ivy)
       (projectile-mode t))
   #+end_src
** Git
*** Magit
    [[https://github.com/magit/magit][Magit]] - A Git porcelain inside Emacs.
   #+begin_src elisp
     (use-package magit
       :general
       (:prefix leader-key
                "g" '(:ignore t :wk "Magit")
                "gg" 'magit-status
                "gf" 'magit-fetch
                "gp" 'magit-pull
                "gb" 'magit-branch
                "gB" 'magit-blame
                "gr" 'vc-refresh-state
                "gl" 'magit-log)
       :config
       (setq magit-save-repository-buffers 'dontask
             magit-refs-show-commit-count 'all))
   #+end_src
*** Forge
    [[https://github.com/magit/forge][Forge]] - Work with Git forges from the comfort of Magit
    #+begin_src elisp
      (use-package forge :after magit)
    #+end_src
** LSP
   UI integrations for lsp-mode
*** LSP
    #+begin_src elisp
      (use-package lsp-mode
        :disabled
        :defer t
        :commands lsp
        :config
        (setq lsp-auto-guess-root nil
              lsp-prefer-flymake nil
              lsp-file-watch-threshold 2000
              read-process-output-max (* 1024 1024)
              lsp-eldoc-hook nil
              lsp-keymap-prefix "C-c l")
        :hook
        ((clojure-mode clojurescript-mode
          js-mode js2-mode web-mode) . lsp))
    #+end_src
*** TODO LSP ui
    #+begin_src elisp
      (use-package lsp-ui
        :disabled
        :after lsp-mode
        :commands lsp-ui-mode
        :bind
        (:map lsp-ui-mode-map
              ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
              ([remap xref-find-references] . lsp-ui-peek-find-references)
              ("C-c u" . lsp-ui-imenu)
              ("M-i" . lsp-ui-doc-focus-frame))
        (:map lsp-mode-map
              ("M-n" . forward-paragraph)
              ("M-p" . backward-paragraph))
        :config
        (setq lsp-ui-doc-header t
              lsp-ui-doc-include-signature t
              lsp-ui-doc-border (face-foreground 'default)
              lsp-ui-sideline-enable nil
              lsp-ui-sideline-ignore-duplicate t
              lsp-ui-sideline-show-code-actions nil
              lsp-ui-doc-use-webkit t))
    #+end_src
** Clojure/ClojureScript
   Clojure settings for Emacs
*** TODO Clojure development environment
    #+begin_src elisp
      (use-package cider
      :hook
      ((cider-mode . eldoc-mode)
       (clojure-mode . cider-mode)
       (clojure-mode . subword-mode)
       (cider-repl-mode . eldoc-mode)
       (cider-repl-mode . subword-mode))
      :bind
      (:map cider-mode-map
            ("C-c m l" . cider-load-all-project-ns)
            ("C-c m j" . cider-jack-in-clj)
            ("C-c m J" . cider-jack-in-cljs)
            :map cider-repl-mode-map
            ("C-c m l" . cider-repl-clear-buffer))
      :config
      (setq cider-offer-to-open-cljs-app-in-browser nil
            cider-font-lock-dynamically t
            cider-invert-insert-eval-p t
            cider-save-file-on-load t
            cider-repl-pop-to-buffer-on-connect 'display-only
            cider-repl-history-file (locate-user-emacs-file "cider-repl-history")
            cider-repl-display-help-banner nil))
    #+end_src
*** Clojure Flycheck
    Flycheck using clj-kondo
    #+begin_src elisp
      (use-package flycheck-clj-kondo)
    #+end_src
*** Font-locking for Clojure mode
    #+begin_src elisp
      (use-package clojure-mode-extra-font-locking
    :after clojure-mode)
    #+end_src
*** Client for Clojure nREPL
    #+begin_src elisp
      (use-package nrepl-client
        :ensure nil
        :after cider
        :config
        (setq nrepl-hide-special-buffers t))
    #+end_src
*** TODO Kaocha test runner
    An emacs package for running Kaocha tests via CIDER.
    #+begin_src elisp
      (use-package kaocha-runner
        :after cider
        :bind
        (:map clojure-mode-map
              ("C-c k a" . kaocha-runner-run-all-tests)
              ("C-c k h" . kaocha-runner-hide-windows)
              ("C-c k r" . kaocha-runner-run-tests)
              ("C-c k t" . kaocha-runner-run-test-at-point)
              ("C-c k w" . kaocha-runner-show-warnings))
        :config
        (setq kaocha-runner-failure-win-min-height 20
              kaocha-runner-ongoing-tests-win-min-height 20
              kaocha-runner-output-win-max-height 20))
    #+end_src
** Javascript
   [[https://github.com/mooz/js2-mode][js2-mode]]: Improved JavaScript editing mode for GNU Emacs.
   #+begin_src elisp
     (use-package js2-mode
       :mode "\\.js\\'"
       :interpreter "node")
   #+end_src
** HTML & CSS
   [[https://github.com/fxbois/web-mode][web-mode]]: an emacs major mode for editing HTML files.
   #+begin_src elisp
     (use-package web-mode
       :mode
       ("\\.njk\\'" "\\.tpl\\.php\\'" "\\.[agj]sp\\'" "\\.as[cp]x\\'"
        "\\.erb\\'" "\\.mustache\\'" "\\.djhtml\\'" "\\.[t]?html?\\'"))
   #+end_src
** YAML
   #+begin_src elisp
     (use-package yaml-mode :defer t)
   #+end_src
** JSON
   #+begin_src elisp
     (use-package json-mode
       :mode "\\.json\\'")
   #+end_src
** Docker
   #+begin_src elisp
     (use-package docker :defer t)
     (use-package dockerfile-mode :defer t)
   #+end_src


* Productivity
** org-mode
*** org settings
    #+begin_src elisp
      (use-package org
        :general
        (:prefix leader-key
                 "o" '(:ignore t :wk "Org-mode")
                 "oo" '(counsel-org-capture :wk "Capture")
                 "Oa" '(org-agenda :wk "Agenda")
                 "o'" '(org-edit-special :wk "Edit special")
                 "og" '(counsel-org-goto :wk "Goto")
                 "os" '(org-todo :wk "Status")
                 "ot" '(counsel-org-tag "Tag")
                 "oS" '(org-schedule :wk "Schedule")
                 "oD" '(org-deadline :wk "Deadline"))
        :custom-face
        (org-block-begin-line ((t (:underline nil))))
        (org-block-end-line ((t (:overline nil))))
        :config
        (setq org-agenda-files (list "~/org/")
              org-default-notes-file "inbox.org"
              org-todo-keywords '((sequence "TODO" "NEXT" "HOLD" "|" "DONE" "CANCEL"))
              org-log-done t
              org-archive-location "~/org/archive.org::datatree/"
              org-hide-emphasis-markers t
              org-ellipsis " ↴"
              org-fontify-quote-and-verse-blocks t))

      (use-package org-refile
        :ensure nil
        :config
        (setq org-refile-targets '((org-agenda-files :maxlevel . 1))
              org-refile-allow-creating-parent-nodes 'confirm))
    #+end_src
*** org-babel
    Settings for literate programming.

    #+begin_src elisp
      (org-babel-do-load-languages
            'org-babel-load-languages
            '((emacs-lisp . t)
              (clojure . t)))

      (setq org-confirm-babel-evaluate nil
            org-src-fontify-natively t
            org-src-tab-acts-natively t
            org-src-window-setup 'reorganize-frame)
    #+end_src
**** ob-clojure-literate
     Setup scaffold for Clojure Literate Programming in Org-mode,
     following [[https://kirang.in/post/setting-up-org-mode-to-run-clojure-code/][this]] guide.

     #+begin_src elisp
       (use-package ob-clojure
         :ensure nil
         :after '(org cider)
         :config
         (setq org-babel-clojure-backend 'cider))
     #+end_src
*** ox-latext
    #+begin_src elisp
      (use-package ox-latex
        :ensure nil
        :config
        (setq org-latex-listings 'minted
              org-latex-packages-alist '(("" "minted"))
              org-latex-pdf-process
              '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
              org-latex-minted-options '(("breaklines" "true")
                                         ("breakanywhere" "true")))
        (add-to-list 'org-latex-classes
                     '("article"
                       "\\documentclass{article}"
                       ("\\section{%s}" . "\\section*{%s}")
                       ("\\subsection{%s}" . "\\subsection*{%s}")
                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
        (add-to-list 'org-latex-classes
                     '("koma-article"
                       "\\documentclass{scrartcl}"
                       ("\\section{%s}" . "\\section*{%s}")
                       ("\\subsection{%s}" . "\\subsection*{%s}")
                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
    #+end_src
*** org-bullets
    Pretty bullets instead of asterisks.
    #+begin_src elisp
      (use-package org-bullets
        :hook
        (org-mode . org-bullets-mode)
        :config
        (setq org-bullets-bullet-list
              '("" "" "" "" "")))
    #+end_src
*** org-mru-clock
    [[https://github.com/unhammer/org-mru-clock][org-mru-clock]] - Pre-fill your clock history with clocks from your agenda
    files (and other open org files) so you can clock in to your most recent
    clocks regardless of whether you just started Emacs or have had it running
    for decades.
    #+begin_src elisp
      (use-package org-mru-clock
        :general
        (:prefix leader-key
                 "oc" '(:ignore t :wk "Clock")
                 "oci" '(org-mru-clock-in :wk "Clock in")
                 "ocr" '(org-mru-clock-select-recent-task :wk "Select task")
                 "oco" '(org-clock-out :wk "Clock out"))
        :init
        (setq org-mru-clock-how-many 10
              org-mru-clock-files #'org-agenda-files))
    #+end_src
*** org-tree-slide
    Presentation tool
    #+begin_src elisp
      (defun my/presentation-setup ()
        (setq text-scale-mode-amount 3)
        (org-display-inline-images)
        (text-scale-mode 1))

      (defun my/presentation-end ()
        (text-scale-mode 0))

      (use-package org-tree-slide
        :hook
        ((org-tree-slide-play . my/presentation-setup)
         (org-tree-slide-stop . my/presentation-end))
        :custom
        (org-image-actual-width nil)
        (org-tree-slide-activate-message "Welcome!")
        (org-tree-slide-deactivate-message "Fin!")
        (org-tree-slide-breadcrumbs " // "))
    #+end_src
*** yankpad
    [[https://github.com/Kungsgeten/yankpad][GitHub - Kungsgeten/yankpad: Paste snippets from an org-mode file]]
    #+begin_src elisp
      (use-package yasnippet
        :ensure t
        :config
        (setq yas-verbosity 1)
        (yas-global-mode))

      (use-package yankpad
        :ensure t
        :after yasnippet
        :general
        (:prefix leader-key
                 "y" '(:ignore t :wk "Snippets")
                 "yc" 'yankpad-set-category
                 "ye" 'yankpad-edit
                 "yi" 'yankpad-insert
                 "ym" 'yankpad-map
                 "yr" 'yankpad-reload
                 "yx" 'yankpad-expand)
        :init
        (setq yankpad-file "~/org/yankpad.org"))
    #+END_SRC
*** capture templates
    #+begin_src elisp
      (setq org-capture-templates
            '(("t" "Task" entry (file "inbox.org")
               "* TODO %?\n")
              ("T" "Clockable task" entry (file+headline "inbox.org")
               "* TODO %?\n" :clock-in t :clock-keep t)
              ("j" "Journal" entry (file+olp+datetree "~/org/journal.org")
               "** %<%H:%M> %?\n")))
    #+end_src


* TODO Useful packages to look at

- [[https://github.com/purcell/page-break-lines][page-break-lines.el]]: provides a global mode which displays ugly form
  feed characters as tidy horizontal rules.


* BEERWARE LICENSE
  "THE BEER-WARE LICENSE" (Revision 42): Marco Dalla Stella
  <marco@dallastella.name> wrote this file. As long as you retain this
  notice you can do whatever you want with this stuff. If we meet some
  day, and you think this stuff is worth it, you can buy me a beer in
  return.
